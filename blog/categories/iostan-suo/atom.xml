<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios探索 | 永不言弃]]></title>
  <link href="http://devcatin.github.io/blog/categories/iostan-suo/atom.xml" rel="self"/>
  <link href="http://devcatin.github.io/"/>
  <updated>2015-04-17T17:42:44+08:00</updated>
  <id>http://devcatin.github.io/</id>
  <author>
    <name><![CDATA[Grant]]></name>
    <email><![CDATA[605435554@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[IOS UIWebView 长按图片保存到本地相册]]></title>
    <link href="http://devcatin.github.io/blog/2015/01/19/ios-uiwebview-chang-an-tu-pian-bao-cun-dao-ben-di-xiang-ce/"/>
    <updated>2015-01-19T13:51:50+08:00</updated>
    <id>http://devcatin.github.io/blog/2015/01/19/ios-uiwebview-chang-an-tu-pian-bao-cun-dao-ben-di-xiang-ce</id>
    <content type="html"><![CDATA[<p>我们所要解决的问题如题目所示：ios中，长按Webview中的图片，将图片保存到本地相册。</p>

<!--more-->


<p>解决方案：对load的html网页，执行js注入，通过在webview中执行js代码，来响应点击事件，通过js代码来模拟长按事件。发现图片的位置，获得图片的url链接，通过此链接获得图片，将此图片保存到本地相册。</p>

<p>js注入代码：</p>

<pre><code>static NSString* const kTouchJavaScriptString=
@"document.ontouchstart=function(event){\
x=event.targetTouches[0].clientX;\
y=event.targetTouches[0].clientY;\
document.location=\"myweb:touch:start:\"+x+\":\"+y;};\
document.ontouchmove=function(event){\
x=event.targetTouches[0].clientX;\
y=event.targetTouches[0].clientY;\
document.location=\"myweb:touch:move:\"+x+\":\"+y;};\
document.ontouchcancel=function(event){\
document.location=\"myweb:touch:cancel\";};\
document.ontouchend=function(event){\
document.location=\"myweb:touch:end\";};";
</code></pre>

<p>在开始之前先要定义几个宏</p>

<p>//#define GESTURE_STATE_START @&ldquo;start&rdquo;</p>

<p>//#define GESTURE_STATE_MOVE  @&ldquo;move&rdquo;</p>

<p>//define  GESTURE_STATE_END   @&ldquo;end&rdquo;</p>

<p>//define SNS_IMAGE_HINT_SAVE_FAILE @&ldquo;Failure&rdquo;</p>

<p>//define SNS_IMAGE_HINT_SAVE_SUCCE @&ldquo;Sucess&rdquo;</p>

<p>@property (strong, nonatomic) NSString *gesState</p>

<p>@property (strong, nonatomic) NSString *imgURL</p>

<p>@property (strong, nonatomic) NSTimer  *timer</p>

<p>js执行代码：</p>

<pre><code class="ruby">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)_request navigationType:(UIWebViewNavigationType)navigationType {
    NSString *requestString = ［_request URL] absoluteString];
    NSArray *components = [requestString componentsSeparatedByString:@":"];
    if ([components count] &gt; 1 &amp;&amp; [(NSString *)[components objectAtIndex:0]
                                   isEqualToString:@"myweb"]) {
        if([(NSString *)[components objectAtIndex:1] isEqualToString:@"touch"])
        {
            //NSLog(@"you are touching!");
            //NSTimeInterval delaytime = Delaytime;
            if ([(NSString *)[components objectAtIndex:2] isEqualToString:@"start"]){
                 /*@需延时判断是否响应页面内的js*/
                _gesState = GESTURE_STATE_START;
                NSLog(@"touch start!");
                float ptX = ［components objectAtIndex:3]floatValue];
                float ptY = ［components objectAtIndex:4]floatValue];
                NSLog(@"touch point (%f, %f)", ptX, ptY);
                NSString *js = [NSString stringWithFormat:@"document.elementFromPoint(%f, %f).tagName", ptX, ptY];
                NSString * tagName = [self.getWebView stringByEvaluatingJavaScriptFromString:js];
                _imgURL = nil;
                if ([tagName isEqualToString:@"IMG"]) {
                    _imgURL = [NSString stringWithFormat:@"document.elementFromPoint(%f, %f).src", ptX, ptY];
                }
                if (_imgURL) {
                    _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(handleLongTouch) userInfo:nil repeats:NO];
                }
            }
            else if ([(NSString *)[components objectAtIndex:2] isEqualToString:@"move"])
            {
                //**如果touch动作是滑动，则取消hanleLongTouch动作**//
                _gesState = GESTURE_STATE_MOVE;
                NSLog(@"you are move");
                }
            }
            else if ([(NSString*)[components objectAtIndex:2]isEqualToString:@"end"]) {
                [_timer invalidate];
                _timer = nil;
                _gesState = GESTURE_STATE_END;
                NSLog(@"touch end");
            }
        }
        return NO;
    }
    return YES;
}
</code></pre>

<p>如果点击的是图片，并且按住的时间超过1s，执行handleLongTouch函数，处理图片的保存操作。</p>

<pre><code>
- (void)handleLongTouch {
    NSLog(@"%@", _imgURL);
    if (_imgURL &amp;&amp; _gesState == GESTURE_STATE_START) {
        UIActionSheet* sheet = ［UIActionSheet alloc]initWithTitle:nil delegate:self cancelButtonTitle:@"取消" destructiveButtonTitle:nil otherButtonTitles:@"保存图片", nil];
        sheet.cancelButtonIndex = sheet.numberOfButtons - 1;
        [sheet showInView:[UIApplication sharedApplication].keyWindow];
    }
}
</code></pre>

<p>将图片保存到相册方法:</p>

<pre><code>
- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex {
    if (actionSheet.numberOfButtons - 1 == buttonIndex) {
        return;
    }
    NSString* title = [actionSheet buttonTitleAtIndex:buttonIndex];
    if ([title isEqualToString:@"保存图片"]) {
        if (_imgURL) {
            NSLog(@"imgurl = %@", _imgURL);
        }
        NSString *urlToSave = [self.getWebView stringByEvaluatingJavaScriptFromString:_imgURL];
        NSLog(@"image url=%@", urlToSave);
        NSData* data = [NSData dataWithContentsOfURL:[NSURL URLWithString:urlToSave］;
        UIImage* image = [UIImage imageWithData:data];
        //UIImageWriteToSavedPhotosAlbum(image, nil, nil,nil);
        UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), nil);
    }
}
</code></pre>

<p>保存成功或失败提示信息:</p>

<pre><code>
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError*)error contextInfo:(void*)contextInfo
{
    if (error){
        NSLog(@"Error");
        [self showAlert:SNS_IMAGE_HINT_SAVE_FAILE];
    }else {
        NSLog(@"OK");
        [self showAlert:SNS_IMAGE_HINT_SAVE_SUCCE];
    }
}
</code></pre>

<p>总结：这篇文章主要是体现objecttive-c和js的交互。通过这篇文章，我们可以将app中UIWebView加载的html页面上的图片保存到自己的相册中。具体Demo就不提供了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于第三方微信授权登录的iOS代码分析]]></title>
    <link href="http://devcatin.github.io/blog/2014/12/17/markdownyu-fa-shuo-ming-jian-ti-zhong-wen-ban/"/>
    <updated>2014-12-17T13:14:31+08:00</updated>
    <id>http://devcatin.github.io/blog/2014/12/17/markdownyu-fa-shuo-ming-jian-ti-zhong-wen-ban</id>
    <content type="html"><![CDATA[<p>微信已经深入到每一个APP的缝隙，最常用的莫过分享和登录了，接下来就以代码的形式来展开微信登录的相关说明，至于原理级别的oauth2.0认证体系请参考微信开放平台的相关说明和图示 <a href="https://open.weixin.qq.com/">https://open.weixin.qq.com/</a></p>

<!--more-->


<h2>微信登录授权开发</h2>

<blockquote><p>1.到微信开发平台注册相关APP，现在是等待审核成功后才能获取到对应的<code>key</code>和<code>secret</code>；获取成功后需要单独申请开通登录和支付接口，如图</p></blockquote>

<p><img src="https://raw.githubusercontent.com/zhangkt/zhangkt.github.com/master/images/blogimages/1411370441623372.png" alt="" /></p>

<p>2.和QQ类似，需要填写<code>Url Schemes</code>，如demo中的wxd930ea5d5a258f4f ，然后引入相应framework；</p>

<p>3.在AppDelegate中注册和实现授权后的回调函数，代码如下：</p>

<pre><code class="ruby">//向微信注册  
  [WXApi registerApp:kWXAPP_ID withDescription:@"weixin"];  
//授权后回调 WXApiDelegate  
-(void)onResp:(BaseReq *)resp  
{  
   /* 
    ErrCode ERR_OK = 0(用户同意) 
    ERR_AUTH_DENIED = -4（用户拒绝授权） 
    ERR_USER_CANCEL = -2（用户取消） 
    code    用户换取access_token的code，仅在ErrCode为0时有效 
    state   第三方程序发送时用来标识其请求的唯一性的标志，由第三方程序调用sendReq时传入，由微信终端回传，state字符串长度不能超过1K 
    lang    微信客户端当前语言 
    country 微信用户当前国家信息 
    */      
    SendAuthResp *aresp = (SendAuthResp *)resp;  
    if (aresp.errCode== 0) {  
        NSString *code = aresp.code;  
        NSDictionary *dic = @{@"code":code};  
    }  
}  
//和QQ,新浪并列回调句柄
- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation  
{  
    return [TencentOAuth HandleOpenURL:url] ||  
    [WeiboSDK handleOpenURL:url delegate:self] ||  
    [WXApi handleOpenURL:url delegate:self];;  
}  
- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url  
{  
    return [TencentOAuth HandleOpenURL:url] ||  
    [WeiboSDK handleOpenURL:url delegate:self] ||  
    [WXApi handleOpenURL:url delegate:self];;  
}
</code></pre>

<p>4.微信登录授权比较复杂，相比QQ，新浪多了几步，简单说就是需要三步，第一步，获取<code>code</code>，这个用来获取token，第二步，就是带上code获取<code>token</code>，第三步，根据第二步获取的token和openid来获取用户的相关信息；</p>

<p>下面用代码来实现：</p>

<p>第一步：code</p>

<pre><code>- (IBAction)weixinLogin:(id)sender  
{  
    [self sendAuthRequest];  
}  
-(void)sendAuthRequest  
{  
    SendAuthReq *req = [[SendAuthReq alloc ] init];  
    req.scope = @"snsapi_userinfo,snsapi_base";  
    req.state = @"0744" ;  
    [WXApi sendReq:req];  
}
</code></pre>

<p>这里获取后会调用之前在AppDelegate里面的对应<code>oauthResp</code>回调，获得得到的<code>code</code>。</p>

<p>第二步：token和openid</p>

<pre><code>-(void)getAccess_token  
{  
    //https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code  
    NSString *url = [NSString stringWithFormat:@"https://api.weixin.qq.com/sns/oauth2/access_token?appid=%@&amp;secret=%@&amp;code=%@&amp;grant_type=authorization_code",kWXAPP_ID,kWXAPP_SECRET,self.wxCode.text];   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{  
        NSURL *zoneUrl = [NSURL URLWithString:url];  
        NSString *zoneStr = [NSString stringWithContentsOfURL:zoneUrl encoding:NSUTF8StringEncoding error:nil];  
        NSData *data = [zoneStr dataUsingEncoding:NSUTF8StringEncoding];  
        dispatch_async(dispatch_get_main_queue(), ^{  
            if (data) {  
                NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];  
              /* 
               { 
               "access_token" = "OezXcEiiBSKSxW0eoylIeJDUKD6z6dmr42JANLPjNN7Kaf3e4GZ2OncrCfiKnGWiusJMZwzQU8kXcnT1hNs_ykAFDfDEuNp6waj-bDdepEzooL_k1vb7EQzhP8plTbD0AgR8zCRi1It3eNS7yRyd5A"; 
               "expires_in" = 7200; 
               openid = oyAaTjsDx7pl4Q42O3sDzDtA7gZs; 
               "refresh_token" = "OezXcEiiBSKSxW0eoylIeJDUKD6z6dmr42JANLPjNN7Kaf3e4GZ2OncrCfiKnGWi2ZzH_XfVVxZbmha9oSFnKAhFsS0iyARkXCa7zPu4MqVRdwyb8J16V8cWw7oNIff0l-5F-4-GJwD8MopmjHXKiA"; 
               scope = "snsapi_userinfo,snsapi_base"; 
               } 
               */   
                self.access_token.text = [dic objectForKey:@"access_token"];  
                self.openid.text = [dic objectForKey:@"openid"];   
            }  
        });  
    });  
}
</code></pre>

<p>利用GCD来获取对应的<code>token</code>和<code>openID</code>.</p>

<p>第三步：userinfo</p>

<pre><code>-(void)getUserInfo  
{  
   // https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID  
    NSString *url = [NSString stringWithFormat:@"https://api.weixin.qq.com/sns/userinfo?access_token=%@&amp;openid=%@",self.access_token.text,self.openid.text];  
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{  
        NSURL *zoneUrl = [NSURL URLWithString:url];  
        NSString *zoneStr = [NSString stringWithContentsOfURL:zoneUrl encoding:NSUTF8StringEncoding error:nil];  
        NSData *data = [zoneStr dataUsingEncoding:NSUTF8StringEncoding];  
        dispatch_async(dispatch_get_main_queue(), ^{  
            if (data) {  
                NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];  
                /*{ 
                 city = Haidian; 
                 country = CN; 
                 headimgurl = "http:/wx.qlogo.cn/mmopen/FrdAUicrPIibcpGzxuD0kjfnvc2klwzQ62a1brlWq1sjNfWREia6W8Cf8kNCbErowsSUcGSIltXTqrhQgPEibYakpl5EokGMibMPU/0"; 
                 language = "zh_CN"; 
                 nickname = "xxx"; 
                 openid = oyAaTjsDx7pl4xxxxxxx; 
                 privilege =     ( 
                 ); 
                 province = Beijing; 
                 sex = 1; 
                 unionid = oyAaTjsxxxxxxQ42O3xxxxxxs; 
                 }*/   
                self.nickname.text = [dic objectForKey:@"nickname"];  
                self.wxHeadImg.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:[dic objectForKey:@"headimgurl"]]]];  
            }  
        });  
    });  
}
</code></pre>

<p>执行到这一步就算完成了整个授权登录的功能，能把昵称和头像显示出来，剩下的就是及时刷新你的token，详情可参考开发文档。</p>

<p>评价：微信的开发文档相比容易理解和调试，虽然没有demo，但是文档比较详细，所以可以在一定程度上减轻了开发的困难，但是相比之下微信的授权步骤比较麻 烦，需要三步才能彻底获取用户信息，这点没有QQ和新浪微博简洁，需要有一定的阅读和代码功底，希望能给大家带来帮助。</p>
]]></content>
  </entry>
  
</feed>
